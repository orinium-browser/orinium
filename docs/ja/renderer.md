# platform::renderer

### 起動フロー (Startup)
1. プロセス起動
   - コマンドラインまたはプロセスマネージャによりrendererが起動（`GpuRenderer::new()`）

2. 初期コンフィグ読み込み
   - 設定（`RendererConfig` 構造体）を読み込み。必須フィールド例: width, height, backend, enable_vsync, memory_limits。
   - 設定検証: 異常値があれば起動失敗（致命的エラー）。メインにエラーを返す場合は起動ハンドシェイク中に通知。

3. ログ／メトリクス初期化
   - 構造化ログ（JSON など）を初期化。
   - メトリクス収集パイプライン（フレームタイム、メモリ、GPU 使用率）を登録。

4. GPU バックエンド初期化
   - 指定された backend を選択して GPU コンテキストを初期化（物理デバイス選択、スワップチェーン／表面の作成、コマンドプールの作成など）。
   - 失敗時: 起動を中止してメインへ詳細を返す（`RenderError::GpuInit`）。

5. IPC エンドポイント作成（リスン）
   - OS ネイティブの名前付きパイプ（Windows）や Unix ドメインソケット／TCP を作成して待ち受ける。
   - 非同期リスナを起動し、メインプロセスからの接続を受け入れる準備をする。

出力: GPU コンテキスト確立済み、IPC 待受中の状態。

### ハンドシェイク／認証フロー (Handshake & Auth)

1. メインプロセス接続開始
   - メインからソケット接続、または既に親が渡したハンドルで通信チャネルが確立される。

2. バージョン／能力交換
   - 互いにメッセージを送り合い、プロトコルバージョン、サポートする機能（ex. 拡張シェーダ、capture_frame）、メッセージ圧縮方式を通知。
   - メッセージ例: `HandshakeRequest { version: 1, features: [...] }` / `HandshakeResponse { accepted: true, renderer_version: "x.y" }`。

3. 認証（オプションだが推奨）
   - 起動引数で渡されたトークンやプロセス間署名を検証して、通信を許可する。
   - 失敗: 接続を切断しログを出す。

4. 初期状態同期
   - メインから初期描画状態（最初の DrawList/シーンツリー）、必要なリソースリスト（テクスチャ、フォント）を受け取る。

成功後: Renderer は main のコマンド受信ループに入る準備ができている。

### 初期リソースロードフロー (Initial Resource Load)

1. リソース受領
   - メインから `ResourceRequest` 一覧を受け取り、優先度（表示に必須かどうか）を付ける。

2. 非同期読み込みワーカーに委譲
   - ファイル I/O、デコード（PNG/JPEG/フォントデコーディングなど）はワーカーで実行。
   - 読み込み完了時にメインへ `ResourceLoaded(id)` を返すか、内部で即時アップロードする。

3. GPU アップロード
   - データが GPU に転送可能な形になったら遅延アップロードキューへ push。
   - アップロードは GPU 提出タイミングで実行して競合を避ける。

4. フォールバック
   - 読み込み失敗時はプレースホルダ（単色テクスチャなど）を用意し、`ResourceError` をメインへ通知する。


### メインコマンド受信ループ（メッセージ処理ループ）

1. 受信スレッド / async ループ
   - IPC 受信は非同期で行い、受け取った `RenderCommand` を受信キューに入れる。
   - 重い処理（デコード、フォント生成）はワーカーへ投げる。

2. コマンドの優先順位付け
   - タイムクリティカルなコマンド（Resize, Draw）は優先度高。
   - バッチング: 同一フレーム内の複数 Draw コマンドは合成して効率的に処理。

3. コマンド適用
   - 受信キューから取り出し、内部状態（シーングラフ、レイヤー状態）へ反映。
   - 必要に応じてリソース参照を解決（存在しない場合は `ResourceRequest` をメインへ要求するか placeholder を使う）。

4. フレーム生成トリガ
   - 受け取ったコマンドによりフレーム生成が要求されたら（明示的な `Draw`、または `VSync` トリガ）、`render_frame` を呼ぶ。
   - VSync/Timer による定期更新がある場合はそれでもトリガが発生する。

### フレーム生成（render_frame）フロー — 各ステージ詳細

前提: このフローは 1 フレーム分の同期経路であり、GPU への提出（submit）が行われるまでを扱う。

1. コマンド整理（Command Flattening）
   - 現在の状態から当フレームで描画すべき DrawList を確定。
   - レイヤー単位で変更検出（dirty flag）を使い、不要な再描画を回避。

2. ワールド→スクリーン変換（Coordinate/Clip）
   - 各 DrawCommand の座標系をスクリーン空間へ変換。
   - クリッピング領域を計算、オクルージョン（簡易）を実施して描画負荷を低減。

3. プリパス（CPU サイド準備）
   - 頂点バッファ／インデックスバッファの生成、ユニフォームデータ組み立て。
   - テクスチャが未アップロードならアップロードキューへ登録。

4. バッチ化・ソート
   - シェーダ／ブレンドモード／テクスチャで DrawCall をソートしてバッチ化し、状態変更回数を削減。

5. GPU コマンド生成
   - GPU コマンドバッファを生成し、必須のパイプライン・バインディング・描画コマンドを記述。

6. GPU 提出（submit）
   - コマンドバッファを GPU に送信し、必要ならフェンスを張る。
   - 非同期経路を採る場合、CPU はすぐ次の処理へ戻るが、リソースの lifetime 管理は注意する。

7. プレゼンテーション
   - スワップチェーン／表面に対して present を呼ぶ（vsync 有効時は垂直同期に従う）。
   - 成功したら `RenderEvent::FramePresented` を生成してメインへ通知する場合がある。

8. ポスト処理（必要なら）
   - フレームキャプチャを要求されていたら同期的にピクセルを読み取り `CapturedFrame` を返す。
   - GPU メモリ使用量の更新やガベージ回収トリガを検査。

成功指標: フレーム生成完了（GPU へ submit した）、または明示的なエラーをメインへ返送。

### リソース管理フロー（Resource lifecycle）

1. リソース識別
   - 各リソースは一意 ID（例: `Uuid`）で管理。
   - 参照カウント＋世代番号で古いハンドルを無効化。

2. ライフサイクル: Request → Load → Upload → Use → Evict
   - Request: メインから `LoadResource(id, kind, data/url)` を受信。
   - Load: ワーカーでデコード／最適化（mipmap 生成等）。
   - Upload: GPU アップロードキューで GPU に転送。
   - Use: DrawCommand で使用。
   - Evict: LRU・閾値オーバー・明示的 `UnloadResource` により GPU/CPU から解放。

3. アロケーションポリシー
   - GPU メモリ予算を config により設定。超過時は低優先度リソースから解放。
   - 重要リソース（UI の主要テクスチャ等）は手動でピン留め可能。

4. エラーとフォールバック
   - アップロード失敗やデコード失敗は `RenderEvent::Error(Resource(...))` を生成し、placeholder を使用。

Generated by chatGPT-5